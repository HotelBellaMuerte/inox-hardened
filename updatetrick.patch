--- a/chrome/browser/ui/webui/settings/chromeos/cups_printers_handler.cc
+++ b/chrome/browser/ui/webui/settings/chromeos/cups_printers_handler.cc
@@ -524,6 +524,12 @@
   CHECK(args->GetDictionary(0, &printer_dict));
 
   Printer printer = DictToPrinter(*printer_dict);
+  PrinterUri uri;
+  if (!ParseUri(printer.uri(), &uri)) {
+    LOG(ERROR) << "Failed to parse printer";
+    OnAddPrinterError(PrinterSetupResult::kFatalError);
+    return;
+  }
 
   // Read PPD selection if it was used.
   std::string ppd_manufacturer;
--- a/components/offline_pages/core/offline_page_storage_manager.cc
+++ b/components/offline_pages/core/offline_page_storage_manager.cc
@@ -217,7 +217,7 @@
 
   // Report usages for all namespaces known to ClientPolicyController and only
   // for those.
-  std::string base_histogram_name = "OfflinePages.ClearStoragePreRunUsage.";
+  std::string base_histogram_name = "OfflinePages.ClearStoragePreRunUsage2.";
   for (const std::string name_space : policy_controller_->GetAllNamespaces()) {
     int size_in_kib = base::saturated_cast<int>(page_sizes[name_space] / 1024);
     base::UmaHistogramCustomCounts(base_histogram_name + name_space,
diff --git a/components/offline_pages/core/offline_page_storage_manager_unittest.cc b/components/offline_pages/core/offline_page_storage_manager_unittest.cc
index 1b979e2..e561222 100644
--- a/components/offline_pages/core/offline_page_storage_manager_unittest.cc
+++ b/components/offline_pages/core/offline_page_storage_manager_unittest.cc
@@ -281,7 +281,7 @@
 
 std::string OfflinePageStorageManagerTest::GetStorageUsageHistogramName(
     const std::string& name_space) {
-  return "OfflinePages.ClearStoragePreRunUsage." + name_space;
+  return "OfflinePages.ClearStoragePreRunUsage2." + name_space;
 }
 
 void OfflinePageStorageManagerTest::CheckTotalCountForAllStorageUsageHistograms(
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index 1e482fa..c0477a6 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -45,10 +45,6 @@
     "//third_party/skia/third_party/vulkan",
   ]
 
-  if (!is_ios) {
-    include_dirs += [ "//third_party/skia/include/codec" ]
-  }
-
   defines = skia_for_chromium_defines
   defines += [
     "SK_HAS_PNG_LIBRARY",
@@ -285,39 +281,16 @@
     "//third_party/skia/src/images/SkPngEncoder.cpp",
     "//third_party/skia/src/images/SkWebpEncoder.cpp",
     "//third_party/skia/src/ports/SkGlobalInitialization_default.cpp",
+    "//third_party/skia/src/ports/SkImageGenerator_none.cpp",
     "//third_party/skia/src/ports/SkOSFile_stdio.cpp",
     "//third_party/skia/src/sfnt/SkOTTable_name.cpp",
     "//third_party/skia/src/sfnt/SkOTUtils.cpp",
   ]
   if (!is_ios) {
     sources += [
-      "//third_party/skia/src/codec/SkBmpBaseCodec.cpp",
-      "//third_party/skia/src/codec/SkBmpCodec.cpp",
-      "//third_party/skia/src/codec/SkBmpMaskCodec.cpp",
-      "//third_party/skia/src/codec/SkBmpRLECodec.cpp",
-      "//third_party/skia/src/codec/SkBmpStandardCodec.cpp",
-      "//third_party/skia/src/codec/SkCodec.cpp",
-      "//third_party/skia/src/codec/SkCodecImageGenerator.cpp",
-      "//third_party/skia/src/codec/SkGifCodec.cpp",
-      "//third_party/skia/src/codec/SkIcoCodec.cpp",
-      "//third_party/skia/src/codec/SkJpegCodec.cpp",
-      "//third_party/skia/src/codec/SkJpegDecoderMgr.cpp",
-      "//third_party/skia/src/codec/SkJpegUtility.cpp",
-      "//third_party/skia/src/codec/SkMaskSwizzler.cpp",
-      "//third_party/skia/src/codec/SkMasks.cpp",
-      "//third_party/skia/src/codec/SkPngCodec.cpp",
-      "//third_party/skia/src/codec/SkSampler.cpp",
-      "//third_party/skia/src/codec/SkStreamBuffer.cpp",
-      "//third_party/skia/src/codec/SkSwizzler.cpp",
-      "//third_party/skia/src/codec/SkWbmpCodec.cpp",
-      "//third_party/skia/src/codec/SkWebpCodec.cpp",
       "//third_party/skia/src/images/SkJPEGWriteUtility.cpp",
       "//third_party/skia/src/images/SkJpegEncoder.cpp",
-      "//third_party/skia/src/ports/SkImageGenerator_skia.cpp",
-      "//third_party/skia/third_party/gif/SkGifImageReader.cpp",
     ]
-  } else {
-    sources += [ "//third_party/skia/src/ports/SkImageGenerator_none.cpp" ]
   }
 
   # This and skia_opts are really the same conceptual target so share headers.
diff --git a/third_party/WebKit/Source/platform/BUILD.gn b/third_party/WebKit/Source/platform/BUILD.gn
index dcd384e..de62e8f 100644
--- a/third_party/WebKit/Source/platform/BUILD.gn
+++ b/third_party/WebKit/Source/platform/BUILD.gn
@@ -1180,14 +1180,14 @@
     "image-decoders/ImageFrame.h",
     "image-decoders/SegmentReader.cpp",
     "image-decoders/SegmentReader.h",
-    "image-decoders/SegmentStream.cpp",
-    "image-decoders/SegmentStream.h",
     "image-decoders/bmp/BMPImageDecoder.cpp",
     "image-decoders/bmp/BMPImageDecoder.h",
     "image-decoders/bmp/BMPImageReader.cpp",
     "image-decoders/bmp/BMPImageReader.h",
     "image-decoders/gif/GIFImageDecoder.cpp",
     "image-decoders/gif/GIFImageDecoder.h",
+    "image-decoders/gif/GIFImageReader.cpp",
+    "image-decoders/gif/GIFImageReader.h",
     "image-decoders/ico/ICOImageDecoder.cpp",
     "image-decoders/ico/ICOImageDecoder.h",
     "image-decoders/jpeg/JPEGImageDecoder.cpp",
@@ -1850,7 +1850,6 @@
     "image-decoders/ImageDecoderTest.cpp",
     "image-decoders/ImageDecoderTestHelpers.cpp",
     "image-decoders/ImageDecoderTestHelpers.h",
-    "image-decoders/SegmentStreamTest.cpp",
     "image-decoders/bmp/BMPImageDecoderTest.cpp",
     "image-decoders/gif/GIFImageDecoderTest.cpp",
     "image-decoders/ico/ICOImageDecoderTest.cpp",
diff --git a/third_party/WebKit/Source/platform/image-decoders/ImageDecoder.h b/third_party/WebKit/Source/platform/image-decoders/ImageDecoder.h
index e440c80..dc40551 100644
--- a/third_party/WebKit/Source/platform/image-decoders/ImageDecoder.h
+++ b/third_party/WebKit/Source/platform/image-decoders/ImageDecoder.h
@@ -253,6 +253,15 @@
   // Callers may pass WTF::kNotFound to clear all frames.
   // Note: If |frame_buffer_cache_| contains only one frame, it won't be
   // cleared. Returns the number of bytes of frame data actually cleared.
+  //
+  // This is a virtual method because MockImageDecoder needs to override it in
+  // order to run the test ImageFrameGeneratorTest::ClearMultiFrameDecode.
+  //
+  // @TODO  Let MockImageDecoder override ImageFrame::ClearFrameBuffer instead,
+  //        so this method can be made non-virtual. It is used in the test
+  //        ImageFrameGeneratorTest::ClearMultiFrameDecode. The test needs to
+  //        be modified since two frames may be kept in cache, instead of
+  //        always just one, with this ClearCacheExceptFrame implementation.
   virtual size_t ClearCacheExceptFrame(size_t);
 
   // If the image has a cursor hot-spot, stores it in the argument
@@ -392,9 +401,7 @@
   // |index| is smaller than |frame_buffer_cache_|.size().
   virtual bool FrameStatusSufficientForSuccessors(size_t index) {
     DCHECK(index < frame_buffer_cache_.size());
-    ImageFrame::Status frame_status = frame_buffer_cache_[index].GetStatus();
-    return frame_status == ImageFrame::kFramePartial ||
-           frame_status == ImageFrame::kFrameComplete;
+    return frame_buffer_cache_[index].GetStatus() != ImageFrame::kFrameEmpty;
   }
 
  private:
diff --git a/third_party/WebKit/Source/platform/image-decoders/ImageFrame.cpp b/third_party/WebKit/Source/platform/image-decoders/ImageFrame.cpp
index cfda667..99c7821 100644
--- a/third_party/WebKit/Source/platform/image-decoders/ImageFrame.cpp
+++ b/third_party/WebKit/Source/platform/image-decoders/ImageFrame.cpp
@@ -82,12 +82,8 @@
   has_alpha_ = other.has_alpha_;
   bitmap_.reset();
   SkImageInfo info = other.bitmap_.info();
-  if (!bitmap_.tryAllocPixels(info)) {
-    return false;
-  }
-
-  status_ = kFrameAllocated;
-  return other.bitmap_.readPixels(info, bitmap_.getPixels(), bitmap_.rowBytes(),
+  return bitmap_.tryAllocPixels(info) &&
+         other.bitmap_.readPixels(info, bitmap_.getPixels(), bitmap_.rowBytes(),
                                   0, 0);
 }
 
@@ -102,7 +98,6 @@
   bitmap_.reset();
   bitmap_.swap(other->bitmap_);
   other->status_ = kFrameEmpty;
-  status_ = kFrameAllocated;
   return true;
 }
 
@@ -116,11 +111,7 @@
       new_width, new_height,
       premultiply_alpha_ ? kPremul_SkAlphaType : kUnpremul_SkAlphaType,
       std::move(color_space)));
-  bool allocated = bitmap_.tryAllocPixels(allocator_);
-  if (allocated)
-    status_ = kFrameAllocated;
-
-  return allocated;
+  return bitmap_.tryAllocPixels(allocator_);
 }
 
 bool ImageFrame::HasAlpha() const {
diff --git a/third_party/WebKit/Source/platform/image-decoders/ImageFrame.h b/third_party/WebKit/Source/platform/image-decoders/ImageFrame.h
index 2af8752..ba6fb6f 100644
--- a/third_party/WebKit/Source/platform/image-decoders/ImageFrame.h
+++ b/third_party/WebKit/Source/platform/image-decoders/ImageFrame.h
@@ -46,7 +46,7 @@
   DISALLOW_NEW_EXCEPT_PLACEMENT_NEW();
 
  public:
-  enum Status { kFrameEmpty, kFrameAllocated, kFramePartial, kFrameComplete };
+  enum Status { kFrameEmpty, kFramePartial, kFrameComplete };
   enum DisposalMethod {
     // If you change the numeric values of these, make sure you audit
     // all users, as some users may cast raw values to/from these
diff --git a/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.cpp b/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.cpp
index a765a78..1879171 100644
--- a/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.cpp
+++ b/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.cpp
@@ -27,9 +27,8 @@
 
 #include <limits>
 #include <memory>
-#include "platform/image-decoders/SegmentStream.h"
+#include "platform/image-decoders/gif/GIFImageReader.h"
 #include "platform/wtf/NotFound.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
 
 namespace blink {
 
@@ -37,306 +36,248 @@
                                  const ColorBehavior& color_behavior,
                                  size_t max_decoded_bytes)
     : ImageDecoder(alpha_option, color_behavior, max_decoded_bytes),
-      codec_(),
-      segment_stream_(nullptr),
-      prior_frame_(SkCodec::kNone) {}
+      repetition_count_(kAnimationLoopOnce) {}
 
-GIFImageDecoder::~GIFImageDecoder() = default;
+GIFImageDecoder::~GIFImageDecoder() {}
 
 void GIFImageDecoder::OnSetData(SegmentReader* data) {
-  if (!data) {
-    if (segment_stream_)
-      segment_stream_->SetReader(nullptr);
-    return;
-  }
-
-  std::unique_ptr<SegmentStream> segment_stream;
-  if (!segment_stream_) {
-    segment_stream = std::make_unique<SegmentStream>();
-    segment_stream_ = segment_stream.get();
-  }
-
-  segment_stream_->SetReader(std::move(data));
-
-  if (!codec_) {
-    SkCodec::Result codec_creation_result;
-    codec_ = SkCodec::MakeFromStream(std::move(segment_stream),
-                                     &codec_creation_result, nullptr);
-    switch (codec_creation_result) {
-      case SkCodec::kSuccess: {
-        // SkCodec::MakeFromStream will read enough of the image to get the
-        // image size.
-        SkImageInfo image_info = codec_->getInfo();
-        SetSize(image_info.width(), image_info.height());
-        return;
-      }
-      case SkCodec::kIncompleteInput:
-        // |segment_stream_|'s ownership is passed into MakeFromStream.
-        // It is deleted if MakeFromStream fails.
-        // If MakeFromStream fails, we set |segment_stream_| to null so
-        // we aren't pointing to reclaimed memory.
-        segment_stream_ = nullptr;
-        return;
-      default:
-        SetFailed();
-        return;
-    }
-  }
+  if (reader_)
+    reader_->SetData(data);
 }
 
 int GIFImageDecoder::RepetitionCount() const {
-  if (!codec_ || segment_stream_->IsCleared())
-    return repetition_count_;
-
-  DCHECK(!Failed());
-
   // This value can arrive at any point in the image data stream.  Most GIFs
   // in the wild declare it near the beginning of the file, so it usually is
   // set by the time we've decoded the size, but (depending on the GIF and the
-  // packets sent back by the webserver) not always.
+  // packets sent back by the webserver) not always.  If the reader hasn't
+  // seen a loop count yet, it will return kCLoopCountNotSeen, in which case we
+  // should default to looping once (the initial value for
+  // |repetition_count_|).
   //
-  // SkCodec will parse forward in the file if the repetition count has not
-  // been seen yet.
-  int repetition_count = codec_->getRepetitionCount();
-
-  switch (repetition_count) {
-    case 0: {
-      // SkCodec returns 0 for both still images and animated images which
-      // only play once.
-      if (IsAllDataReceived() && codec_->getFrameCount() == 1) {
-        repetition_count_ = kAnimationNone;
-        break;
-      }
-
-      repetition_count_ = kAnimationLoopOnce;
-      break;
-    }
-    case SkCodec::kRepetitionCountInfinite:
-      repetition_count_ = kAnimationLoopInfinite;
-      break;
-    default:
-      repetition_count_ = repetition_count;
-      break;
-  }
-
+  // There are some additional wrinkles here. First, ImageSource::Clear()
+  // may destroy the reader, making the result from the reader _less_
+  // authoritative on future calls if the recreated reader hasn't seen the
+  // loop count.  We don't need to special-case this because in this case the
+  // new reader will once again return kCLoopCountNotSeen, and we won't
+  // overwrite the cached correct value.
+  //
+  // Second, a GIF might never set a loop count at all, in which case we
+  // should continue to treat it as a "loop once" animation.  We don't need
+  // special code here either, because in this case we'll never change
+  // |repetition_count_| from its default value.
+  //
+  // Third, we use the same GIFImageReader for counting frames and we might
+  // see the loop count and then encounter a decoding error which happens
+  // later in the stream. It is also possible that no frames are in the
+  // stream. In these cases we should just loop once.
+  if (IsAllDataReceived() && ParseCompleted() && reader_->ImagesCount() == 1)
+    repetition_count_ = kAnimationNone;
+  else if (Failed() || (reader_ && (!reader_->ImagesCount())))
+    repetition_count_ = kAnimationLoopOnce;
+  else if (reader_ && reader_->LoopCount() != kCLoopCountNotSeen)
+    repetition_count_ = reader_->LoopCount();
   return repetition_count_;
 }
 
 bool GIFImageDecoder::FrameIsReceivedAtIndex(size_t index) const {
-  SkCodec::FrameInfo frame_info;
-  if (!codec_ || !codec_->getFrameInfo(index, &frame_info))
-    return false;
-  return frame_info.fFullyReceived;
+  return reader_ && (index < reader_->ImagesCount()) &&
+         reader_->FrameContext(index)->IsComplete();
 }
 
 TimeDelta GIFImageDecoder::FrameDurationAtIndex(size_t index) const {
-  if (index < frame_buffer_cache_.size())
-    return frame_buffer_cache_[index].Duration();
-  return TimeDelta();
+  return (reader_ && (index < reader_->ImagesCount()) &&
+          reader_->FrameContext(index)->IsHeaderDefined())
+             ? TimeDelta::FromMilliseconds(
+                   reader_->FrameContext(index)->DelayTime())
+             : TimeDelta();
 }
 
 bool GIFImageDecoder::SetFailed() {
-  segment_stream_ = nullptr;
-  codec_.reset();
+  reader_.reset();
   return ImageDecoder::SetFailed();
 }
 
-size_t GIFImageDecoder::ClearCacheExceptFrame(size_t index) {
-  // SkCodec attempts to report the earliest possible required frame, but it is
-  // possible that frame has been evicted, while a later frame (which could also
-  // be used as the required frame) is still cached. Try to preserve a frame
-  // that is still cached.
-  if (frame_buffer_cache_.size() <= 1)
-    return 0;
+bool GIFImageDecoder::HaveDecodedRow(size_t frame_index,
+                                     GIFRow::const_iterator row_begin,
+                                     size_t width,
+                                     size_t row_number,
+                                     unsigned repeat_count,
+                                     bool write_transparent_pixels) {
+  const GIFFrameContext* frame_context = reader_->FrameContext(frame_index);
+  // The pixel data and coordinates supplied to us are relative to the frame's
+  // origin within the entire image size, i.e.
+  // (frameC_context->xOffset, frame_context->yOffset). There is no guarantee
+  // that width == (size().width() - frame_context->xOffset), so
+  // we must ensure we don't run off the end of either the source data or the
+  // row's X-coordinates.
+  const int x_begin = frame_context->XOffset();
+  const int y_begin = frame_context->YOffset() + row_number;
+  const int x_end = std::min(static_cast<int>(frame_context->XOffset() + width),
+                             Size().Width());
+  const int y_end = std::min(
+      static_cast<int>(frame_context->YOffset() + row_number + repeat_count),
+      Size().Height());
+  if (!width || (x_begin < 0) || (y_begin < 0) || (x_end <= x_begin) ||
+      (y_end <= y_begin))
+    return true;
 
-  size_t index2 = kNotFound;
-  if (index < frame_buffer_cache_.size()) {
-    const ImageFrame& frame = frame_buffer_cache_[index];
-    if (frame.RequiredPreviousFrameIndex() != kNotFound &&
-        (!FrameStatusSufficientForSuccessors(index) ||
-         frame.GetDisposalMethod() == ImageFrame::kDisposeOverwritePrevious)) {
-      index2 = GetViableReferenceFrameIndex(index);
+  const GIFColorMap::Table& color_table =
+      frame_context->LocalColorMap().IsDefined()
+          ? frame_context->LocalColorMap().GetTable()
+          : reader_->GlobalColorMap().GetTable();
+
+  if (color_table.IsEmpty())
+    return true;
+
+  GIFColorMap::Table::const_iterator color_table_iter = color_table.begin();
+
+  // Initialize the frame if necessary.
+  ImageFrame& buffer = frame_buffer_cache_[frame_index];
+  if (!InitFrameBuffer(frame_index))
+    return false;
+
+  const size_t transparent_pixel = frame_context->TransparentPixel();
+  GIFRow::const_iterator row_end = row_begin + (x_end - x_begin);
+  ImageFrame::PixelData* current_address = buffer.GetAddr(x_begin, y_begin);
+
+  // We may or may not need to write transparent pixels to the buffer.
+  // If we're compositing against a previous image, it's wrong, and if
+  // we're writing atop a cleared, fully transparent buffer, it's
+  // unnecessary; but if we're decoding an interlaced gif and
+  // displaying it "Haeberli"-style, we must write these for passes
+  // beyond the first, or the initial passes will "show through" the
+  // later ones.
+  //
+  // The loops below are almost identical. One writes a transparent pixel
+  // and one doesn't based on the value of |write_transparent_pixels|.
+  // The condition check is taken out of the loop to enhance performance.
+  // This optimization reduces decoding time by about 15% for a 3MB image.
+  if (write_transparent_pixels) {
+    for (; row_begin != row_end; ++row_begin, ++current_address) {
+      const size_t source_value = *row_begin;
+      if ((source_value != transparent_pixel) &&
+          (source_value < color_table.size())) {
+        *current_address = color_table_iter[source_value];
+      } else {
+        *current_address = 0;
+        current_buffer_saw_alpha_ = true;
+      }
+    }
+  } else {
+    for (; row_begin != row_end; ++row_begin, ++current_address) {
+      const size_t source_value = *row_begin;
+      if ((source_value != transparent_pixel) &&
+          (source_value < color_table.size()))
+        *current_address = color_table_iter[source_value];
+      else
+        current_buffer_saw_alpha_ = true;
     }
   }
 
-  return ClearCacheExceptTwoFrames(index, index2);
+  // Tell the frame to copy the row data if need be.
+  if (repeat_count > 1)
+    buffer.CopyRowNTimes(x_begin, x_end, y_begin, y_end);
+
+  buffer.SetPixelsChanged(true);
+  return true;
+}
+
+bool GIFImageDecoder::ParseCompleted() const {
+  return reader_ && reader_->ParseCompleted();
+}
+
+bool GIFImageDecoder::FrameComplete(size_t frame_index) {
+  // Initialize the frame if necessary.  Some GIFs insert do-nothing frames,
+  // in which case we never reach HaveDecodedRow() before getting here.
+  if (!InitFrameBuffer(frame_index))
+    return SetFailed();
+
+  if (!current_buffer_saw_alpha_)
+    CorrectAlphaWhenFrameBufferSawNoAlpha(frame_index);
+
+  frame_buffer_cache_[frame_index].SetStatus(ImageFrame::kFrameComplete);
+
+  return true;
+}
+
+void GIFImageDecoder::ClearFrameBuffer(size_t frame_index) {
+  if (reader_ && frame_buffer_cache_[frame_index].GetStatus() ==
+                     ImageFrame::kFramePartial) {
+    // Reset the state of the partial frame in the reader so that the frame
+    // can be decoded again when requested.
+    reader_->ClearDecodeState(frame_index);
+  }
+  ImageDecoder::ClearFrameBuffer(frame_index);
 }
 
 size_t GIFImageDecoder::DecodeFrameCount() {
-  if (!codec_ || segment_stream_->IsCleared())
-    return frame_buffer_cache_.size();
-
-  return codec_->getFrameCount();
+  Parse(kGIFFrameCountQuery);
+  // If decoding fails, |reader_| will have been destroyed.  Instead of
+  // returning 0 in this case, return the existing number of frames.  This way
+  // if we get halfway through the image before decoding fails, we won't
+  // suddenly start reporting that the image has zero frames.
+  return Failed() ? frame_buffer_cache_.size() : reader_->ImagesCount();
 }
 
 void GIFImageDecoder::InitializeNewFrame(size_t index) {
-  DCHECK(codec_);
-
-  ImageFrame& frame = frame_buffer_cache_[index];
-  // SkCodec does not inform us if only a portion of the image was updated
-  // in the current frame. Because of this, rather than correctly filling in
-  // the frame rect, we set the frame rect to be the image's full size.
-  // The original frame rect is not used, anyway.
-  IntSize full_image_size = Size();
-  frame.SetOriginalFrameRect(IntRect(IntPoint(), full_image_size));
-
-  SkCodec::FrameInfo frame_info;
-  bool frame_info_received = codec_->getFrameInfo(index, &frame_info);
-  DCHECK(frame_info_received);
-  frame.SetDuration(TimeDelta::FromMilliseconds(frame_info.fDuration));
-  size_t required_previous_frame_index;
-  if (frame_info.fRequiredFrame == SkCodec::kNone) {
-    required_previous_frame_index = kNotFound;
-  } else {
-    required_previous_frame_index =
-        static_cast<size_t>(frame_info.fRequiredFrame);
-  }
-  frame.SetRequiredPreviousFrameIndex(required_previous_frame_index);
-
-  ImageFrame::DisposalMethod disposal_method = ImageFrame::kDisposeNotSpecified;
-  switch (frame_info.fDisposalMethod) {
-    case SkCodecAnimation::DisposalMethod::kKeep:
-      disposal_method = ImageFrame::kDisposeKeep;
-      break;
-    case SkCodecAnimation::DisposalMethod::kRestoreBGColor:
-      disposal_method = ImageFrame::kDisposeOverwriteBgcolor;
-      break;
-    case SkCodecAnimation::DisposalMethod::kRestorePrevious:
-      disposal_method = ImageFrame::kDisposeOverwritePrevious;
-      break;
-  }
-  frame.SetDisposalMethod(disposal_method);
+  ImageFrame* buffer = &frame_buffer_cache_[index];
+  const GIFFrameContext* frame_context = reader_->FrameContext(index);
+  buffer->SetOriginalFrameRect(
+      Intersection(frame_context->FrameRect(), IntRect(IntPoint(), Size())));
+  buffer->SetDuration(TimeDelta::FromMilliseconds(frame_context->DelayTime()));
+  buffer->SetDisposalMethod(frame_context->GetDisposalMethod());
+  buffer->SetRequiredPreviousFrameIndex(
+      FindRequiredPreviousFrame(index, false));
 }
 
 void GIFImageDecoder::Decode(size_t index) {
-  if (!codec_ || segment_stream_->IsCleared())
+  Parse(kGIFFrameCountQuery);
+
+  if (Failed())
     return;
 
-  DCHECK(!Failed());
-
-  DCHECK_LT(index, frame_buffer_cache_.size());
-
   UpdateAggressivePurging(index);
 
-  ImageFrame& frame = frame_buffer_cache_[index];
-  if (frame.GetStatus() == ImageFrame::kFrameEmpty) {
-    size_t required_previous_frame_index = frame.RequiredPreviousFrameIndex();
-    if (required_previous_frame_index == kNotFound) {
-      frame.AllocatePixelData(Size().Width(), Size().Height(),
-                              ColorSpaceForSkImages());
-      frame.ZeroFillPixelData();
-      prior_frame_ = SkCodec::kNone;
-    } else {
-      size_t previous_frame_index = GetViableReferenceFrameIndex(index);
-      if (previous_frame_index == kNotFound) {
-        previous_frame_index = required_previous_frame_index;
-        Decode(previous_frame_index);
-        if (Failed()) {
-          return;
-        }
-      }
-
-      // We try to reuse |previous_frame| as starting state to avoid copying.
-      // If CanReusePreviousFrameBuffer returns false, we must copy the data
-      // since |previous_frame| is necessary to decode this or later frames.
-      // In that case copy the data instead.
-      ImageFrame& previous_frame = frame_buffer_cache_[previous_frame_index];
-      if ((!CanReusePreviousFrameBuffer(index) ||
-           !frame.TakeBitmapDataIfWritable(&previous_frame)) &&
-          !frame.CopyBitmapData(previous_frame)) {
-        SetFailed();
-        return;
-      }
-      prior_frame_ = previous_frame_index;
-    }
-  }
-
-  if (frame.GetStatus() == ImageFrame::kFrameAllocated) {
-    SkImageInfo image_info = codec_->getInfo()
-                                 .makeColorType(kN32_SkColorType)
-                                 .makeColorSpace(ColorSpaceForSkImages());
-
-    SkCodec::Options options;
-    options.fFrameIndex = index;
-    options.fPriorFrame = prior_frame_;
-    options.fZeroInitialized = SkCodec::kNo_ZeroInitialized;
-
-    SkCodec::Result start_incremental_decode_result =
-        codec_->startIncrementalDecode(image_info, frame.Bitmap().getPixels(),
-                                       frame.Bitmap().rowBytes(), &options);
-    switch (start_incremental_decode_result) {
-      case SkCodec::kSuccess:
-        break;
-      case SkCodec::kIncompleteInput:
-        return;
-      default:
-        SetFailed();
-        return;
-    }
-    frame.SetStatus(ImageFrame::kFramePartial);
-  }
-
-  SkCodec::Result incremental_decode_result = codec_->incrementalDecode();
-  switch (incremental_decode_result) {
-    case SkCodec::kSuccess: {
-      SkCodec::FrameInfo frame_info;
-      bool frame_info_received = codec_->getFrameInfo(index, &frame_info);
-      DCHECK(frame_info_received);
-      frame.SetHasAlpha(frame_info.fAlpha != SkEncodedInfo::kOpaque_Alpha);
-      frame.SetPixelsChanged(true);
-      frame.SetStatus(ImageFrame::kFrameComplete);
-      PostDecodeProcessing(index);
-      break;
-    }
-    case SkCodec::kIncompleteInput:
-      frame.SetPixelsChanged(true);
-      if (FrameIsReceivedAtIndex(index) || IsAllDataReceived()) {
-        SetFailed();
-      }
-      break;
-    default:
+  Vector<size_t> frames_to_decode = FindFramesToDecode(index);
+  for (auto i = frames_to_decode.rbegin(); i != frames_to_decode.rend(); ++i) {
+    if (!reader_->Decode(*i)) {
       SetFailed();
+      return;
+    }
+
+    // If this returns false, we need more data to continue decoding.
+    if (!PostDecodeProcessing(*i))
       break;
   }
+
+  // It is also a fatal error if all data is received and we have decoded all
+  // frames available but the file is truncated.
+  if (index >= frame_buffer_cache_.size() - 1 && IsAllDataReceived() &&
+      reader_ && !reader_->ParseCompleted())
+    SetFailed();
 }
 
-bool GIFImageDecoder::CanReusePreviousFrameBuffer(size_t index) const {
-  DCHECK_LT(index, frame_buffer_cache_.size());
-  return frame_buffer_cache_[index].GetDisposalMethod() !=
-         ImageFrame::kDisposeOverwritePrevious;
-}
+void GIFImageDecoder::Parse(GIFParseQuery query) {
+  if (Failed())
+    return;
 
-size_t GIFImageDecoder::GetViableReferenceFrameIndex(
-    size_t dependent_index) const {
-  DCHECK_LT(dependent_index, frame_buffer_cache_.size());
-
-  size_t required_previous_frame_index =
-      frame_buffer_cache_[dependent_index].RequiredPreviousFrameIndex();
-
-  // Any frame in the range [|required_previous_frame_index|, |dependent_index|)
-  // which has a disposal method other than kRestorePrevious can be provided as
-  // the prior frame to SkCodec.
-  //
-  // SkCodec sets SkCodec::FrameInfo::fRequiredFrame to the earliest frame which
-  // can be used. This might come up when several frames update the same
-  // subregion. If that same subregion is about to be overwritten, it doesn't
-  // matter which frame in that chain is provided.
-  DCHECK_NE(required_previous_frame_index, kNotFound);
-  // Loop backwards because the frames most likely to be in cache are the most
-  // recent.
-  for (size_t i = dependent_index - 1; i != required_previous_frame_index;
-       i--) {
-    const ImageFrame& frame = frame_buffer_cache_[i];
-
-    if (frame.GetDisposalMethod() == ImageFrame::kDisposeOverwritePrevious)
-      continue;
-
-    if (frame.GetStatus() == ImageFrame::kFrameComplete) {
-      return i;
-    }
+  if (!reader_) {
+    reader_ = WTF::MakeUnique<GIFImageReader>(this);
+    reader_->SetData(data_);
   }
 
-  return kNotFound;
+  if (!reader_->Parse(query))
+    SetFailed();
+}
+
+void GIFImageDecoder::OnInitFrameBuffer(size_t frame_index) {
+  current_buffer_saw_alpha_ = false;
+}
+
+bool GIFImageDecoder::CanReusePreviousFrameBuffer(size_t frame_index) const {
+  DCHECK(frame_index < frame_buffer_cache_.size());
+  return frame_buffer_cache_[frame_index].GetDisposalMethod() !=
+         ImageFrame::kDisposeOverwritePrevious;
 }
 
 }  // namespace blink
diff --git a/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.h b/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.h
index 505f11d..44523dcf 100644
--- a/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.h
+++ b/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoder.h
@@ -29,13 +29,13 @@
 #include <memory>
 #include "platform/image-decoders/ImageDecoder.h"
 #include "platform/wtf/Noncopyable.h"
-#include "platform/wtf/RefPtr.h"
 #include "platform/wtf/Time.h"
-#include "third_party/skia/include/codec/SkCodec.h"
 
 namespace blink {
 
-class SegmentStream;
+class GIFImageReader;
+
+using GIFRow = Vector<unsigned char>;
 
 // This class decodes the GIF image format.
 class PLATFORM_EXPORT GIFImageDecoder final : public ImageDecoder {
@@ -45,43 +45,56 @@
   GIFImageDecoder(AlphaOption, const ColorBehavior&, size_t max_decoded_bytes);
   ~GIFImageDecoder() override;
 
+  enum GIFParseQuery { kGIFSizeQuery, kGIFFrameCountQuery };
+
   // ImageDecoder:
   String FilenameExtension() const override { return "gif"; }
   void OnSetData(SegmentReader* data) override;
   int RepetitionCount() const override;
   bool FrameIsReceivedAtIndex(size_t) const override;
   TimeDelta FrameDurationAtIndex(size_t) const override;
-  // CAUTION: SetFailed() deletes |codec_|. Be careful to avoid
-  // accessing deleted memory.
+  // CAUTION: SetFailed() deletes |reader_|.  Be careful to avoid
+  // accessing deleted memory, especially when calling this from inside
+  // GIFImageReader!
   bool SetFailed() override;
 
-  size_t ClearCacheExceptFrame(size_t) override;
+  // Callbacks from the GIF reader.
+  bool HaveDecodedRow(size_t frame_index,
+                      GIFRow::const_iterator row_begin,
+                      size_t width,
+                      size_t row_number,
+                      unsigned repeat_count,
+                      bool write_transparent_pixels);
+  bool FrameComplete(size_t frame_index);
+
+  // For testing.
+  bool ParseCompleted() const;
 
  private:
   // ImageDecoder:
-  void DecodeSize() override {}
+  void ClearFrameBuffer(size_t frame_index) override;
+  virtual void DecodeSize() { Parse(kGIFSizeQuery); }
   size_t DecodeFrameCount() override;
   void InitializeNewFrame(size_t) override;
   void Decode(size_t) override;
+
+  // Parses as much as is needed to answer the query, ignoring bitmap
+  // data. If parsing fails, sets the "decode failure" flag.
+  void Parse(GIFParseQuery);
+
+  // Reset the alpha tracker for this frame. Before calling this method, the
+  // caller must verify that the frame exists.
+  void OnInitFrameBuffer(size_t) override;
+
   // When the disposal method of the frame is DisposeOverWritePrevious, the
-  // next frame will use a previous frame's buffer as its starting state, so
+  // next frame will use the previous frame's buffer as its starting state, so
   // we can't take over the data in that case. Before calling this method, the
   // caller must verify that the frame exists.
   bool CanReusePreviousFrameBuffer(size_t) const override;
 
-  // When a frame depends on a previous frame's content, there is a list of
-  // candidate reference frames. This function will find a previous frame from
-  // that list which satisfies the requirements of being a reference frame
-  // (kFrameComplete, not kDisposeOverwritePrevious).
-  // If no frame is found, it returns kNotFound.
-  size_t GetViableReferenceFrameIndex(size_t) const;
-
-  std::unique_ptr<SkCodec> codec_;
-  // |codec_| owns the SegmentStream, but we need access to it to append more
-  // data as it arrives.
-  SegmentStream* segment_stream_;
-  mutable int repetition_count_ = kAnimationLoopOnce;
-  int prior_frame_;
+  bool current_buffer_saw_alpha_;
+  mutable int repetition_count_;
+  std::unique_ptr<GIFImageReader> reader_;
 };
 
 }  // namespace blink
diff --git a/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoderTest.cpp b/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoderTest.cpp
index 7ad0428..55f7142 100644
--- a/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoderTest.cpp
+++ b/third_party/WebKit/Source/platform/image-decoders/gif/GIFImageDecoderTest.cpp
@@ -58,8 +58,16 @@
   RefPtr<SharedBuffer> data = ReadFile(dir, file);
   ASSERT_TRUE(data.get());
   decoder->SetData(data.get(), true);
+  EXPECT_EQ(kAnimationLoopOnce,
+            decoder->RepetitionCount());  // Default value before decode.
 
-  EXPECT_EQ(expected_repetition_count, decoder->RepetitionCount());
+  for (size_t i = 0; i < decoder->FrameCount(); ++i) {
+    ImageFrame* frame = decoder->DecodeFrameBufferAtIndex(i);
+    EXPECT_EQ(ImageFrame::kFrameComplete, frame->GetStatus());
+  }
+
+  EXPECT_EQ(expected_repetition_count,
+            decoder->RepetitionCount());  // Expected value after decode.
 }
 
 }  // anonymous namespace
@@ -70,6 +78,7 @@
   RefPtr<SharedBuffer> data = ReadFile(kLayoutTestResourcesDir, "animated.gif");
   ASSERT_TRUE(data.get());
   decoder->SetData(data.get(), true);
+  EXPECT_EQ(kAnimationLoopOnce, decoder->RepetitionCount());
 
   ImageFrame* frame = decoder->DecodeFrameBufferAtIndex(0);
   uint32_t generation_id0 = frame->Bitmap().getGenerationID();
@@ -94,6 +103,10 @@
   RefPtr<SharedBuffer> data = ReadFile(kLayoutTestResourcesDir, "animated.gif");
   ASSERT_TRUE(data.get());
   decoder->SetData(data.get(), true);
+  EXPECT_EQ(kAnimationLoopOnce, decoder->RepetitionCount());
+
+  // This call will parse the entire file.
+  EXPECT_EQ(2u, decoder->FrameCount());
 
   ImageFrame* frame = decoder->DecodeFrameBufferAtIndex(0);
   EXPECT_EQ(ImageFrame::kFrameComplete, frame->GetStatus());
@@ -307,13 +320,10 @@
 
   EXPECT_EQ(2u, decoder->FrameCount());
   // Disposal method 4 is converted to ImageFrame::DisposeOverwritePrevious.
-  // This is because some specs say method 3 is "overwrite previous", while
-  // others say setting the third bit (i.e. method 4) is.
   EXPECT_EQ(ImageFrame::kDisposeOverwritePrevious,
             decoder->DecodeFrameBufferAtIndex(0)->GetDisposalMethod());
-  // Unknown disposal methods (5 in this case) are converted to
-  // ImageFrame::DisposeKeep.
-  EXPECT_EQ(ImageFrame::kDisposeKeep,
+  // Disposal method 5 is ignored.
+  EXPECT_EQ(ImageFrame::kDisposeNotSpecified,
             decoder->DecodeFrameBufferAtIndex(1)->GetDisposalMethod());
 }
 
@@ -380,11 +390,11 @@
   ImageFrame* premul_frame = premul_decoder->DecodeFrameBufferAtIndex(0);
   EXPECT_TRUE(premul_frame &&
               premul_frame->GetStatus() != ImageFrame::kFrameComplete);
-  EXPECT_EQ(kPremul_SkAlphaType, premul_frame->Bitmap().alphaType());
+  EXPECT_EQ(premul_frame->Bitmap().alphaType(), kPremul_SkAlphaType);
   ImageFrame* unpremul_frame = unpremul_decoder->DecodeFrameBufferAtIndex(0);
   EXPECT_TRUE(unpremul_frame &&
               unpremul_frame->GetStatus() != ImageFrame::kFrameComplete);
-  EXPECT_EQ(kUnpremul_SkAlphaType, unpremul_frame->Bitmap().alphaType());
+  EXPECT_EQ(unpremul_frame->Bitmap().alphaType(), kUnpremul_SkAlphaType);
 
   // Fully decoded frame => the frame alpha type is known (opaque).
   premul_decoder->SetData(full_data_buffer.get(), true);
@@ -394,11 +404,11 @@
   premul_frame = premul_decoder->DecodeFrameBufferAtIndex(0);
   EXPECT_TRUE(premul_frame &&
               premul_frame->GetStatus() == ImageFrame::kFrameComplete);
-  EXPECT_EQ(kOpaque_SkAlphaType, premul_frame->Bitmap().alphaType());
+  EXPECT_EQ(premul_frame->Bitmap().alphaType(), kOpaque_SkAlphaType);
   unpremul_frame = unpremul_decoder->DecodeFrameBufferAtIndex(0);
   EXPECT_TRUE(unpremul_frame &&
               unpremul_frame->GetStatus() == ImageFrame::kFrameComplete);
-  EXPECT_EQ(kOpaque_SkAlphaType, unpremul_frame->Bitmap().alphaType());
+  EXPECT_EQ(unpremul_frame->Bitmap().alphaType(), kOpaque_SkAlphaType);
 }
 
 namespace {
--- a/remoting/host/host_attributes.cc
+++ b/remoting/host/host_attributes.cc
@@ -117,9 +117,9 @@
     }
   }
 
-  if (media::InitializeMediaFoundation() &&
-      media::MediaFoundationVideoEncodeAccelerator
-      ::PreSandboxInitialization()) {
+  if (media::MediaFoundationVideoEncodeAccelerator
+      ::PreSandboxInitialization() &&
+      media::InitializeMediaFoundation()) {
     result.push_back("HWEncoder");
   }
 #elif defined(OS_LINUX)
--- a/components/data_reduction_proxy/core/browser/data_reduction_proxy_delegate_unittest.cc
+++ b/components/data_reduction_proxy/core/browser/data_reduction_proxy_delegate_unittest.cc
@@ -762,37 +762,57 @@
 }
 
 TEST_F(DataReductionProxyDelegateTest, OnCompletedSizeFor200) {
-  base::HistogramTester histogram_tester;
-  int64_t baseline_received_bytes = total_received_bytes();
-  int64_t baseline_original_received_bytes = total_original_received_bytes();
-
-  const char kDrpResponseHeaders[] =
-      "HTTP/1.1 200 OK\r\n"
-      "Date: Wed, 28 Nov 2007 09:40:09 GMT\r\n"
-      "Warning: 199 Misc-Agent \"some warning text\"\r\n"
-      "Via:\r\n"
-      "Via: 1.1 Chrome-Compression-Proxy-Suffix, 9.9 other-proxy\r\n"
-      "Via: 2.2 Chrome-Compression-Proxy\r\n"
-      "Warning: 214 Chrome-Compression-Proxy \"Transformation Applied\"\r\n"
-      "X-Original-Content-Length: 10000\r\n"
-      "Chrome-Proxy: q=low\r\n"
-      "Content-Length: 1000\r\n\r\n";
+  const struct {
+    const std::string DrpResponseHeaders;
+  } test_cases[] = {
+      {
+          "HTTP/1.1 200 OK\r\n"
+          "Date: Wed, 28 Nov 2007 09:40:09 GMT\r\n"
+          "Warning: 199 Misc-Agent \"some warning text\"\r\n"
+          "Via:\r\n"
+          "Via: 1.1 Chrome-Compression-Proxy-Suffix, 9.9 other-proxy\r\n"
+          "Via: 2.2 Chrome-Compression-Proxy\r\n"
+          "Warning: 214 Chrome-Compression-Proxy \"Transformation Applied\"\r\n"
+          "X-Original-Content-Length: 10000\r\n"
+          "Chrome-Proxy: q=low\r\n"
+          "Content-Length: 1000\r\n\r\n",
+      },
+      {
+          "HTTP/1.1 200 OK\r\n"
+          "Date: Wed, 28 Nov 2007 09:40:09 GMT\r\n"
+          "Warning: 199 Misc-Agent \"some warning text\"\r\n"
+          "Via:\r\n"
+          "Via: 1.1 Chrome-Compression-Proxy-Suffix, 9.9 other-proxy\r\n"
+          "Via: 2.2 Chrome-Compression-Proxy\r\n"
+          "Warning: 214 Chrome-Compression-Proxy \"Transformation Applied\"\r\n"
+          "Chrome-Proxy: q=low,ofcl=10000\r\n"
+          "Content-Length: 1000\r\n\r\n",
+      }};
 
   params()->UseNonSecureProxiesForHttp();
-  std::unique_ptr<net::URLRequest> request = FetchURLRequest(
-      GURL("http://example.com/path/"), nullptr, kDrpResponseHeaders, 1000);
 
-  EXPECT_EQ(request->GetTotalReceivedBytes(),
-            total_received_bytes() - baseline_received_bytes);
+  for (const auto& test : test_cases) {
+    base::HistogramTester histogram_tester;
+    int64_t baseline_received_bytes = total_received_bytes();
+    int64_t baseline_original_received_bytes = total_original_received_bytes();
 
-  const std::string raw_headers = net::HttpUtil::AssembleRawHeaders(
-      kDrpResponseHeaders, arraysize(kDrpResponseHeaders) - 1);
-  EXPECT_EQ(static_cast<int64_t>(raw_headers.size() +
-                                 10000 /* original_response_body */),
-            total_original_received_bytes() - baseline_original_received_bytes);
+    std::unique_ptr<net::URLRequest> request =
+        FetchURLRequest(GURL("http://example.com/path/"), nullptr,
+                        test.DrpResponseHeaders.c_str(), 1000);
 
-  histogram_tester.ExpectUniqueSample(
-      "DataReductionProxy.ConfigService.HTTPRequests", 1, 1);
+    EXPECT_EQ(request->GetTotalReceivedBytes(),
+              total_received_bytes() - baseline_received_bytes);
+
+    const std::string raw_headers = net::HttpUtil::AssembleRawHeaders(
+        test.DrpResponseHeaders.c_str(), test.DrpResponseHeaders.size());
+    EXPECT_EQ(
+        static_cast<int64_t>(raw_headers.size() +
+                             10000 /* original_response_body */),
+        total_original_received_bytes() - baseline_original_received_bytes);
+
+    histogram_tester.ExpectUniqueSample(
+        "DataReductionProxy.ConfigService.HTTPRequests", 1, 1);
+  }
 }
 
 TEST_F(DataReductionProxyDelegateTest, TimeToFirstHttpDataSaverRequest) {
@@ -881,26 +901,39 @@
 }
 
 TEST_F(DataReductionProxyDelegateTest, OnCompletedSizeFor304) {
-  int64_t baseline_received_bytes = total_received_bytes();
-  int64_t baseline_original_received_bytes = total_original_received_bytes();
-
-  const char kDrpResponseHeaders[] =
-      "HTTP/1.1 304 Not Modified\r\n"
-      "Via: 1.1 Chrome-Compression-Proxy\r\n"
-      "X-Original-Content-Length: 10000\r\n\r\n";
+  const struct {
+    const std::string DrpResponseHeaders;
+  } test_cases[] = {{
+                        "HTTP/1.1 304 Not Modified\r\n"
+                        "Via: 1.1 Chrome-Compression-Proxy\r\n"
+                        "X-Original-Content-Length: 10000\r\n\r\n",
+                    },
+                    {
+                        "HTTP/1.1 304 Not Modified\r\n"
+                        "Via: 1.1 Chrome-Compression-Proxy\r\n"
+                        "Chrome-Proxy: ofcl=10000\r\n\r\n",
+                    }};
 
   params()->UseNonSecureProxiesForHttp();
-  std::unique_ptr<net::URLRequest> request = FetchURLRequest(
-      GURL("http://example.com/path/"), nullptr, kDrpResponseHeaders, 0);
 
-  EXPECT_EQ(request->GetTotalReceivedBytes(),
-            total_received_bytes() - baseline_received_bytes);
+  for (const auto& test : test_cases) {
+    int64_t baseline_received_bytes = total_received_bytes();
+    int64_t baseline_original_received_bytes = total_original_received_bytes();
 
-  const std::string raw_headers = net::HttpUtil::AssembleRawHeaders(
-      kDrpResponseHeaders, arraysize(kDrpResponseHeaders) - 1);
-  EXPECT_EQ(static_cast<int64_t>(raw_headers.size() +
-                                 10000 /* original_response_body */),
-            total_original_received_bytes() - baseline_original_received_bytes);
+    std::unique_ptr<net::URLRequest> request =
+        FetchURLRequest(GURL("http://example.com/path/"), nullptr,
+                        test.DrpResponseHeaders.c_str(), 0);
+
+    EXPECT_EQ(request->GetTotalReceivedBytes(),
+              total_received_bytes() - baseline_received_bytes);
+
+    const std::string raw_headers = net::HttpUtil::AssembleRawHeaders(
+        test.DrpResponseHeaders.c_str(), test.DrpResponseHeaders.size());
+    EXPECT_EQ(
+        static_cast<int64_t>(raw_headers.size() +
+                             10000 /* original_response_body */),
+        total_original_received_bytes() - baseline_original_received_bytes);
+  }
 }
 
 TEST_F(DataReductionProxyDelegateTest, OnCompletedSizeForWriteError) {
@@ -1014,6 +1047,18 @@
            base::Int64ToString((static_cast<int64_t>(1) << 60) * 3) +
            "\r\n\r\n",
        100, 300},
+      {"HTTP/1.1 206 Partial Content\r\n"
+       "Content-Range: bytes 0-19/40\r\n"
+       "Content-Length: 20\r\n"
+       "Via: 1.1 Chrome-Compression-Proxy\r\n"
+       "Chrome-Proxy: ofcl=160\r\n\r\n",
+       20, 80},
+      {"HTTP/1.1 206 Partial Content\r\n"
+       "Content-Range: bytes 0-9/40\r\n"
+       "Content-Length: 10\r\n"
+       "Via: 1.1 Chrome-Compression-Proxy\r\n"
+       "Chrome-Proxy: ofcl=160\r\n\r\n",
+       10, 40},
   };
 
   params()->UseNonSecureProxiesForHttp();
diff --git a/components/data_reduction_proxy/core/browser/data_reduction_proxy_network_delegate.cc b/components/data_reduction_proxy/core/browser/data_reduction_proxy_network_delegate.cc
index 9c778de..69d5d1a 100644
--- a/components/data_reduction_proxy/core/browser/data_reduction_proxy_network_delegate.cc
+++ b/components/data_reduction_proxy/core/browser/data_reduction_proxy_network_delegate.cc
@@ -125,8 +125,8 @@
                                    int64_t original_content_length,
                                    const base::TimeDelta& freshness_lifetime,
                                    DataReductionProxyRequestType request_type) {
-  // Add the current resource to these histograms only when a valid
-  // X-Original-Content-Length header is present.
+  // Add the current resource to these histograms only when the content length
+  // is valid.
   if (original_content_length >= 0) {
     UMA_HISTOGRAM_COUNTS_1M("Net.HttpContentLengthWithValidOCL",
                             received_content_length);
@@ -149,7 +149,7 @@
 
   } else {
     // Presume the original content length is the same as the received content
-    // length if the X-Original-Content-Header is not present.
+    // length.
     original_content_length = received_content_length;
   }
   UMA_HISTOGRAM_COUNTS_1M("Net.HttpContentLength", received_content_length);
@@ -542,16 +542,9 @@
   DataReductionProxyRequestType request_type = GetDataReductionProxyRequestType(
       *request, configurator_->GetProxyConfig(), *data_reduction_proxy_config_);
 
-  // Determine the original content length if present.
-  int64_t original_content_length =
-      request->response_headers()
-          ? request->response_headers()->GetInt64HeaderValue(
-                "x-original-content-length")
-          : -1;
-
   CalculateAndRecordDataUsage(*request, request_type);
-
-  RecordContentLength(*request, request_type, original_content_length);
+  RecordContentLength(*request, request_type,
+                      util::CalculateOCLFromOFCL(*request));
   RecordAcceptTransformReceivedUMA(*request);
 }
 
diff --git a/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.cc b/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.cc
index b9c2c6a..0daa7b6 100644
--- a/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.cc
+++ b/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.cc
@@ -520,4 +520,14 @@
   }
 }
 
+int64_t GetDataReductionProxyOFCL(const net::HttpResponseHeaders* headers) {
+  std::string ofcl_str;
+  int64_t ofcl;
+  if (GetDataReductionProxyActionValue(headers, "ofcl", &ofcl_str) &&
+      base::StringToInt64(ofcl_str, &ofcl) && ofcl >= 0) {
+    return ofcl;
+  }
+  return -1;
+}
+
 }  // namespace data_reduction_proxy
diff --git a/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.h b/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.h
index e7e855d..e8e07e3 100644
--- a/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.h
+++ b/components/data_reduction_proxy/core/common/data_reduction_proxy_headers.h
@@ -209,5 +209,9 @@
     const net::HttpResponseHeaders* headers,
     std::vector<std::string>* values);
 
+// Returns the OFCL value in the Chrome-Proxy header. Returns -1 in case of
+// of error or if OFCL does not exist. |headers| must be non-null.
+int64_t GetDataReductionProxyOFCL(const net::HttpResponseHeaders* headers);
+
 }  // namespace data_reduction_proxy
 #endif  // COMPONENTS_DATA_REDUCTION_PROXY_CORE_COMMON_DATA_REDUCTION_PROXY_HEADERS_H_
diff --git a/components/data_reduction_proxy/core/common/data_reduction_proxy_util.cc b/components/data_reduction_proxy/core/common/data_reduction_proxy_util.cc
index a8b5857..788a033 100644
--- a/components/data_reduction_proxy/core/common/data_reduction_proxy_util.cc
+++ b/components/data_reduction_proxy/core/common/data_reduction_proxy_util.cc
@@ -9,11 +9,13 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/time/time.h"
 #include "base/version.h"
+#include "components/data_reduction_proxy/core/common/data_reduction_proxy_headers.h"
 #include "components/data_reduction_proxy/core/common/lofi_decider.h"
 #include "components/data_reduction_proxy/core/common/version.h"
 #include "net/base/net_errors.h"
 #include "net/base/url_util.h"
 #include "net/http/http_response_headers.h"
+#include "net/http/http_status_code.h"
 #include "net/http/http_util.h"
 #include "net/proxy/proxy_config.h"
 #include "net/proxy/proxy_info.h"
@@ -179,12 +181,40 @@
   return !data_reduction_proxy_info->proxy_server().is_direct();
 }
 
+int64_t CalculateOCLFromOFCL(const net::URLRequest& request) {
+  const net::HttpResponseHeaders* response_headers = request.response_headers();
+  if (!response_headers)
+    return request.received_response_content_length();
+
+  int64_t original_content_length = GetDataReductionProxyOFCL(response_headers);
+
+  if (response_headers->response_code() == net::HTTP_PARTIAL_CONTENT) {
+    int64_t first, last, range_content_length;
+    if (response_headers->GetContentRangeFor206(&first, &last,
+                                                &range_content_length) &&
+        range_content_length > 0 && original_content_length > 0) {
+      // For a range request, OFCL indicates the original content length of the
+      // entire resource. The received response content length should be scaled
+      // by the compression ratio given by OFCL / range_content_length.
+      original_content_length =
+          ScaleByteCountByRatio(request.received_response_content_length(),
+                                original_content_length, range_content_length);
+    }
+  }
+  if (original_content_length < 0) {
+    // Fallback to using XOCL if getting from OFCL header fails.
+    // TODO(rajendrant): Remove the usage of OFCL, after integration tests are
+    // changed.
+    original_content_length =
+        response_headers->GetInt64HeaderValue("x-original-content-length");
+  }
+  return original_content_length;
+}
+
 int64_t CalculateEffectiveOCL(const net::URLRequest& request) {
   if (request.was_cached() || !request.response_headers())
     return request.received_response_content_length();
-  int64_t original_content_length_from_header =
-      request.response_headers()->GetInt64HeaderValue(
-          "x-original-content-length");
+  int64_t original_content_length_from_header = CalculateOCLFromOFCL(request);
 
   if (original_content_length_from_header < 0)
     return request.received_response_content_length();
diff --git a/components/data_reduction_proxy/core/common/data_reduction_proxy_util.h b/components/data_reduction_proxy/core/common/data_reduction_proxy_util.h
index 07784ef..a40f358 100644
--- a/components/data_reduction_proxy/core/common/data_reduction_proxy_util.h
+++ b/components/data_reduction_proxy/core/common/data_reduction_proxy_util.h
@@ -97,8 +97,16 @@
                                  const GURL& url,
                                  net::ProxyInfo* data_reduction_proxy_info);
 
-// Calculates the effective original content length of the |request|, accounting
-// for partial responses if necessary.
+// Calculates the original content length (OCL) of the |request|, from the OFCL
+// value in the Chrome-Proxy header. |request| must not be cached. This does not
+// account for partial failed responses.
+int64_t CalculateOCLFromOFCL(const net::URLRequest& request);
+
+// Calculates the effective original content length of the |request|. For
+// successful requests OCL will be obtained from OFCL if available or from
+// received response length. For partial failed responses an estimate is
+// provided by scaling received response length based on OFCL and Content-Length
+// header.
 int64_t CalculateEffectiveOCL(const net::URLRequest& request);
 
 // Given a |request| that went through the Data Reduction Proxy if |used_drp| is
--- a/net/quic/core/quic_client_promised_info.cc
+++ b/net/quic/core/quic_client_promised_info.cc
@@ -43,7 +43,11 @@
   // RFC7540, Section 8.2, requests MUST be safe [RFC7231], Section
   // 4.2.1.  GET and HEAD are the methods that are safe and required.
   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);
-  DCHECK(it != headers.end());
+  if (it == headers.end()) {
+    QUIC_DVLOG(1) << "Promise for stream " << id_ << " has no method";
+    Reset(QUIC_INVALID_PROMISE_METHOD);
+    return;
+  }
   if (!(it->second == "GET" || it->second == "HEAD")) {
     QUIC_DVLOG(1) << "Promise for stream " << id_ << " has invalid method "
                   << it->second;
diff --git a/net/quic/core/quic_client_promised_info_test.cc b/net/quic/core/quic_client_promised_info_test.cc
index 70d0ac6..9d5d758 100644
--- a/net/quic/core/quic_client_promised_info_test.cc
+++ b/net/quic/core/quic_client_promised_info_test.cc
@@ -154,6 +154,19 @@
   EXPECT_EQ(session_.GetPromisedByUrl(promise_url_), nullptr);
 }
 
+TEST_F(QuicClientPromisedInfoTest, PushPromiseMissingMethod) {
+  // Promise with a missing method
+  push_promise_.erase(":method");
+
+  EXPECT_CALL(*connection_,
+              SendRstStream(promise_id_, QUIC_INVALID_PROMISE_METHOD, 0));
+  ReceivePromise(promise_id_);
+
+  // Verify that the promise headers were ignored
+  EXPECT_EQ(session_.GetPromisedById(promise_id_), nullptr);
+  EXPECT_EQ(session_.GetPromisedByUrl(promise_url_), nullptr);
+}
+
 TEST_F(QuicClientPromisedInfoTest, PushPromiseInvalidUrl) {
   // Remove required header field to make URL invalid
   push_promise_.erase(":authority");
--- a/chrome/browser/ui/cocoa/content_settings/blocked_plugin_bubble_controller.mm
+++ b/chrome/browser/ui/cocoa/content_settings/blocked_plugin_bubble_controller.mm
@@ -45,7 +45,7 @@
   // The size of this bubble, and the other layout constants elsewhere in this
   // file, were lifted from ContentBlockedPlugins.xib
   base::scoped_nsobject<InfoBubbleWindow> window([[InfoBubbleWindow alloc]
-      initWithContentRect:NSMakeRect(0, 0, 314, 179)
+      initWithContentRect:NSMakeRect(0, 0, 314, 145)
                 styleMask:NSBorderlessWindowMask
                   backing:NSBackingStoreBuffered
                     defer:NO]);
--- a/chrome/browser/ui/app_list/arc/arc_app_list_prefs.cc
+++ b/chrome/browser/ui/app_list/arc/arc_app_list_prefs.cc
@@ -24,6 +24,7 @@
 #include "chrome/browser/ui/app_list/arc/arc_app_list_prefs_factory.h"
 #include "chrome/browser/ui/app_list/arc/arc_app_utils.h"
 #include "chrome/browser/ui/app_list/arc/arc_package_syncable_service.h"
+#include "chrome/browser/ui/app_list/arc/arc_pai_starter.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/arc/arc_prefs.h"
 #include "components/arc/arc_service_manager.h"
@@ -58,7 +59,7 @@
 constexpr char kUninstalled[] = "uninstalled";
 
 constexpr base::TimeDelta kDetectDefaultAppAvailabilityTimeout =
-    base::TimeDelta::FromSeconds(15);
+    base::TimeDelta::FromMinutes(1);
 
 // Provider of write access to a dictionary storing ARC prefs.
 class ScopedArcPrefUpdate : public DictionaryPrefUpdate {
@@ -1073,8 +1074,19 @@
 
   if (!is_initialized_) {
     is_initialized_ = true;
-    MaybeSetDefaultAppLoadingTimeout();
+
     UMA_HISTOGRAM_COUNTS_1000("Arc.AppsInstalledAtStartup", ready_apps_.size());
+
+    arc::ArcPaiStarter* pai_starter =
+        arc::ArcSessionManager::Get()->pai_starter();
+
+    if (pai_starter) {
+      pai_starter->AddOnStartCallback(
+          base::BindOnce(&ArcAppListPrefs::MaybeSetDefaultAppLoadingTimeout,
+                         weak_ptr_factory_.GetWeakPtr()));
+    } else {
+      MaybeSetDefaultAppLoadingTimeout();
+    }
   }
 }
 
diff --git a/chrome/browser/ui/app_list/arc/arc_app_unittest.cc b/chrome/browser/ui/app_list/arc/arc_app_unittest.cc
index 23dc0f9..1ebe86d 100644
--- a/chrome/browser/ui/app_list/arc/arc_app_unittest.cc
+++ b/chrome/browser/ui/app_list/arc/arc_app_unittest.cc
@@ -166,6 +166,10 @@
     ArcState::ARC_PERSISTENT_PLAY_STORE_UNMANAGED,
 };
 
+void OnPaiStartedCallback(bool* started_flag) {
+  *started_flag = true;
+}
+
 }  // namespace
 
 class ArcAppModelBuilderTest : public extensions::ExtensionServiceTestBase,
@@ -1258,12 +1262,18 @@
   ArcAppListPrefs* prefs = ArcAppListPrefs::Get(profile_.get());
   ASSERT_TRUE(prefs);
 
+  bool pai_started = false;
+
   arc::ArcPaiStarter starter1(profile_.get(), profile_->GetPrefs());
   arc::ArcPaiStarter starter2(profile_.get(), profile_->GetPrefs());
   EXPECT_FALSE(starter1.started());
   EXPECT_FALSE(starter2.started());
   EXPECT_EQ(app_instance()->start_pai_request_count(), 0);
 
+  starter1.AddOnStartCallback(
+      base::BindOnce(&OnPaiStartedCallback, &pai_started));
+  EXPECT_FALSE(pai_started);
+
   arc::ArcSessionManager* session_manager = arc::ArcSessionManager::Get();
   ASSERT_TRUE(session_manager);
 
@@ -1281,6 +1291,14 @@
   SendPlayStoreApp();
 
   EXPECT_TRUE(starter1.started());
+  EXPECT_TRUE(pai_started);
+
+  // Test that callback is called immediately in case PAI was already started.
+  pai_started = false;
+  starter1.AddOnStartCallback(
+      base::BindOnce(&OnPaiStartedCallback, &pai_started));
+  EXPECT_TRUE(pai_started);
+
   EXPECT_FALSE(starter2.started());
   EXPECT_TRUE(session_manager->pai_starter()->started());
   EXPECT_EQ(app_instance()->start_pai_request_count(), 2);
@@ -1954,12 +1972,46 @@
   app_instance()->RefreshAppList();
   app_instance()->SendRefreshAppList(empty_app_list);
 
-  ValidateHaveApps(fake_default_apps());
+  std::vector<arc::mojom::AppInfo> expected_apps(fake_default_apps());
+  ValidateHaveApps(expected_apps);
+
+  if (GetParam() == ArcState::ARC_PERSISTENT_WITHOUT_PLAY_STORE) {
+    prefs->SimulateDefaultAppAvailabilityTimeoutForTesting();
+    ValidateHaveApps(std::vector<arc::mojom::AppInfo>());
+    return;
+  }
+
+  // PAI was not started and we should not have any active timer for default
+  // apps.
+  prefs->SimulateDefaultAppAvailabilityTimeoutForTesting();
+  ValidateHaveApps(expected_apps);
+
+  arc::ArcSessionManager* arc_session_manager = arc::ArcSessionManager::Get();
+  ASSERT_TRUE(arc_session_manager);
+
+  arc::ArcPaiStarter* pai_starter = arc_session_manager->pai_starter();
+  ASSERT_TRUE(pai_starter);
+
+  EXPECT_FALSE(pai_starter->started());
+
+  // Play store app triggers PAI.
+  arc::mojom::AppInfo app;
+  app.name = "Play Store";
+  app.package_name = arc::kPlayStorePackage;
+  app.activity = arc::kPlayStoreActivity;
+  app_instance()->RefreshAppList();
+
+  std::vector<arc::mojom::AppInfo> only_play_store({app});
+  app_instance()->SendRefreshAppList(only_play_store);
+  expected_apps.push_back(app);
+
+  // Timer was set to detect not available default apps.
+  ValidateHaveApps(expected_apps);
 
   prefs->SimulateDefaultAppAvailabilityTimeoutForTesting();
 
   // No default app installation and already installed packages.
-  ValidateHaveApps(empty_app_list);
+  ValidateHaveApps(only_play_store);
 }
 
 TEST_P(ArcDefaulAppTest, DefaultAppsInstallation) {
diff --git a/chrome/browser/ui/app_list/arc/arc_pai_starter.cc b/chrome/browser/ui/app_list/arc/arc_pai_starter.cc
index 289aa521..7e2d617e 100644
--- a/chrome/browser/ui/app_list/arc/arc_pai_starter.cc
+++ b/chrome/browser/ui/app_list/arc/arc_pai_starter.cc
@@ -52,6 +52,15 @@
   MaybeStartPai();
 }
 
+void ArcPaiStarter::AddOnStartCallback(base::OnceClosure callback) {
+  if (started_) {
+    std::move(callback).Run();
+    return;
+  }
+
+  onstart_callbacks_.push_back(std::move(callback));
+}
+
 void ArcPaiStarter::MaybeStartPai() {
   if (started_ || locked_)
     return;
@@ -71,6 +80,15 @@
   pref_service_->SetBoolean(prefs::kArcPaiStarted, true);
 
   prefs->RemoveObserver(this);
+
+  for (auto& callback : onstart_callbacks_)
+    std::move(callback).Run();
+  onstart_callbacks_.clear();
+}
+
+void ArcPaiStarter::OnAppRegistered(const std::string& app_id,
+                                    const ArcAppListPrefs::AppInfo& app_info) {
+  OnAppReadyChanged(app_id, app_info.ready);
 }
 
 void ArcPaiStarter::OnAppReadyChanged(const std::string& app_id, bool ready) {
diff --git a/chrome/browser/ui/app_list/arc/arc_pai_starter.h b/chrome/browser/ui/app_list/arc/arc_pai_starter.h
index db4973d..b168986 100644
--- a/chrome/browser/ui/app_list/arc/arc_pai_starter.h
+++ b/chrome/browser/ui/app_list/arc/arc_pai_starter.h
@@ -5,6 +5,9 @@
 #ifndef CHROME_BROWSER_UI_APP_LIST_ARC_ARC_PAI_STARTER_H_
 #define CHROME_BROWSER_UI_APP_LIST_ARC_ARC_PAI_STARTER_H_
 
+#include <vector>
+
+#include "base/callback.h"
 #include "base/macros.h"
 #include "chrome/browser/ui/app_list/arc/arc_app_list_prefs.h"
 
@@ -36,6 +39,10 @@
   // is ready at this moment then PAI is started immediately.
   void ReleaseLock();
 
+  // Registers callback that is called once PAI has been started. If PAI is
+  // started already then callback is called immediately.
+  void AddOnStartCallback(base::OnceClosure callback);
+
   // Returns true if lock was acquired.
   bool locked() const { return locked_; }
 
@@ -45,10 +52,13 @@
   void MaybeStartPai();
 
   // ArcAppListPrefs::Observer:
+  void OnAppRegistered(const std::string& app_id,
+                       const ArcAppListPrefs::AppInfo& app_info) override;
   void OnAppReadyChanged(const std::string& app_id, bool ready) override;
 
   content::BrowserContext* const context_;
   PrefService* const pref_service_;
+  std::vector<base::OnceClosure> onstart_callbacks_;
   bool locked_ = false;
   bool started_ = false;
 
